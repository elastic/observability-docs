[[elastic-agent-processor-configuration]]
== Processors

Use processors in the {agent} configuration to process events before they are
sent to the configured output. {agent} supports processors that:

* reduce the number of exported fields
* enhance events with additional metadata
* perform additional processing and decoding

Each processor receives an event, applies a defined action to the event, and
returns the event. If you define a list of processors, they are executed in the
order they are defined in the {agent} configuration file.

[source,yaml]
-------
event -> processor 1 -> event1 -> processor 2 -> event2 ...
-------

[discrete]
[[defining-processors]]
=== Define processors

To define a processor, you specify the processor name, an optional condition,
and a set of parameters:

[source,yaml]
------
processors:
  - <processor_name>:
      when:
        <condition>
      <parameters>

  - <processor_name>:
      when:
        <condition>
      <parameters>

...
------

Where:

* `<processor_name>` specifies a <<processors,processor>> that performs some
action, such as selecting the fields that are exported or adding metadata to
the event.
* `<condition>` specifies an optional <<conditions,condition>>. If the
condition is present, then the action is executed only if the condition is
fulfilled. If no condition is set, then the action is always executed.
* `<parameters>` is the list of parameters to pass to the processor.

More complex conditional processing can be accomplished by using the
if-then-else processor configuration. This allows multiple processors to be
executed based on a single condition.

[source,yaml]
----
processors:
  - if:
      <condition>
    then: <1>
      - <processor_name>:
          <parameters>
      - <processor_name>:
          <parameters>
      ...
    else: <2>
      - <processor_name>:
          <parameters>
      - <processor_name>:
          <parameters>
      ...
----
<1> `then` must contain a single processor or a list of one or more processors
to execute when the condition evaluates to true.
<2> `else` is optional. It can contain a single processor or a list of
processors to execute when the conditional evaluates to false.

[discrete]
[[where-valid]]
=== Where are processors valid?

Processors are valid:

* At the top-level in the configuration. The processor is applied to all data
collected by {agent}.
* Under a specific input. The processor is applied to the data
collected for that input. For example:
+
[source,yaml]
------
- type: <input_type>
  processors:
    - <processor_name>:
        when:
          <condition>
        <parameters>
...
------
+
Similarly, you can define processors under the `input` section of the
configuration.

//QUESTION: Are we missing any other scopes here?

[[processors]]
=== Suported processors

The supported processors are:

include::processors-list.asciidoc[tag=processors-list]

[discrete]
[[processor-conditions]]
=== Conditions

Each condition receives a field to compare. You can specify multiple fields
under the same condition by using `AND` between the fields (for example,
`field1 AND field2`).

For each field, you can specify a simple field name or a nested map, for example
`dns.question.name`.

See the integrations documentation for a list of all the fields that are
generated by a specific integration.

//TODO: Add link to integrations documentation when it's available on the web.

The supported conditions are:

* <<processor-condition-equals,`equals`>>
* <<processor-condition-contains,`contains`>>
* <<processor-condition-regexp,`regexp`>>
* <<processor-condition-range, `range`>>
* <<processor-condition-network, `network`>>
* <<processor-condition-has_fields, `has_fields`>>
* <<processor-condition-or, `or`>>
* <<processor-condition-and, `and`>>
* <<processor-condition-not, `not`>>


[discrete]
[[processor-condition-equals]]
==== `equals`

With the `equals` condition, you can compare if a field has a certain value.
The condition accepts only an integer or a string value.

For example, the following condition checks if the response code of the HTTP
transaction is 200:

[source,yaml]
-------
equals:
  http.response.code: 200
-------

[discrete]
[[processor-condition-contains]]
==== `contains`

The `contains` condition checks if a value is part of a field. The field can be
a string or an array of strings. The condition accepts only a string value.

For example, the following condition checks if an error is part of the
transaction status:

[source,yaml]
------
contains:
  status: "Specific error"
------

[discrete]
[[processor-condition-regexp]]
==== `regexp`

The `regexp` condition checks the field against a regular expression. The
condition accepts only strings.

For example, the following condition checks if the process name starts with
`foo`:

[source,yaml]
-----
regexp:
  system.process.name: "^foo.*"
-----

[discrete]
[[processor-condition-range]]
==== `range`

The `range` condition checks if the field is in a certain range of values. The
condition supports `lt`, `lte`, `gt` and `gte`. The condition accepts only
integer or float values.

For example, the following condition checks for failed HTTP transactions by
comparing the `http.response.code` field with 400.


[source,yaml]
------
range:
  http.response.code:
    gte: 400
------

This can also be written as:

[source,yaml]
----
range:
  http.response.code.gte: 400
----

The following condition checks if the CPU usage in percentage has a value
between 0.5 and 0.8.

[source,yaml]
------
range:
  system.cpu.user.pct.gte: 0.5
  system.cpu.user.pct.lt: 0.8
------

[discrete]
[[processor-condition-network]]
==== `network`

The `network` condition checks if the field is in a certain IP network range.
Both IPv4 and IPv6 addresses are supported. The network range may be specified
using CIDR notation, like "192.0.2.0/24" or "2001:db8::/32", or by using one of
these named ranges:

- `loopback` - Matches loopback addresses in the range of `127.0.0.0/8` or
  `::1/128`.
- `unicast` - Matches global unicast addresses defined in RFC 1122, RFC 4632,
  and RFC 4291 with the exception of the IPv4 broadcast address
  (`255.255.255.255`). This includes private address ranges.
- `multicast` - Matches multicast addresses.
- `interface_local_multicast` - Matches IPv6 interface-local multicast addresses.
- `link_local_unicast` - Matches link-local unicast addresses.
- `link_local_multicast` - Matches link-local multicast addresses.
- `private` - Matches private address ranges defined in RFC 1918 (IPv4) and
  RFC 4193 (IPv6).
- `public` - Matches addresses that are not loopback, unspecified, IPv4
  broadcast, link-local unicast, link-local multicast, interface-local
  multicast, or private.
- `unspecified` - Matches unspecified addresses (either the IPv4 address
  "0.0.0.0" or the IPv6 address "::").

The following condition returns true if the `source.ip` value is within the
private address space.

[source,yaml]
----
network:
  source.ip: private
----

This condition returns true if the `destination.ip` value is within the
IPv4 range of `192.168.1.0` - `192.168.1.255`.

[source,yaml]
----
network:
  destination.ip: '192.168.1.0/24'
----

And this condition returns true when `destination.ip` is within any of the given
subnets.

[source,yaml]
----
network:
  destination.ip: ['192.168.1.0/24', '10.0.0.0/8', loopback]
----

[discrete]
[[processor-condition-has_fields]]
==== `has_fields`

The `has_fields` condition checks if all the given fields exist in the
event. The condition accepts a list of string values denoting the field names.

For example, the following condition checks if the `http.response.code` field
is present in the event.


[source,yaml]
------
has_fields: ['http.response.code']
------


[discrete]
[[processor-condition-or]]
==== `or`

The `or` operator receives a list of conditions.

[source,yaml]
-------
or:
  - <condition1>
  - <condition2>
  - <condition3>
  ...

-------

For example, to configure the condition
`http.response.code = 304 OR http.response.code = 404`:

[source,yaml]
------
or:
  - equals:
      http.response.code: 304
  - equals:
      http.response.code: 404
------

[discrete]
[[processor-condition-and]]
==== `and`

The `and` operator receives a list of conditions.

[source,yaml]
-------
and:
  - <condition1>
  - <condition2>
  - <condition3>
  ...

-------

For example, to configure the condition
`http.response.code = 200 AND status = OK`:

[source,yaml]
------
and:
  - equals:
      http.response.code: 200
  - equals:
      status: OK
------

To configure a condition like `<condition1> OR <condition2> AND <condition3>`:

[source,yaml]
------
or:
  - <condition1>
  - and:
    - <condition2>
    - <condition3>

------

[discrete]
[[processor-condition-not]]
==== `not`

The `not` operator receives the condition to negate.

[source,yaml]
-------
not:
  <condition>

-------

For example, to configure the condition `NOT status = OK`:

[source,yaml]
------
not:
  equals:
    status: OK
------

include::processors-list.asciidoc[tag=processors-include]
