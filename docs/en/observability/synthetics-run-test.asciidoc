[[synthetic-run-tests]]
= Create a browser monitor

beta[]

Once you've <<synthetics-create-test, written a synthetic test>>,
you can create a _monitor_ to run the test at a regular interval.
You can either:

* <<synthetic-monitor-choose-project>> to create monitors from an external source.
* <<synthetics-inline-journey>> to create a new monitor in the {uptime-app} UI
and copy simple journey code into its configuration.

image::images/uptime-set-up-app-browser.png[Diagram showing which pieces of software are used to configure monitors, create monitors, and view results when using the Uptime App. Described in detail in Diagram text description.]

[[diagram-text-app-browser]]
[%collapsible]
.Diagram text description
====
. There are two possible places to start:
    * *Project monitors*: Create a **Project using @elastic/synthetics** using `elastic-synthetics init`.
      Then, add and configure journeys.
    * *Inline monitors*: Configure a new monitor in **{kib}**, specifically the **{observability} {uptime-app}**.
. How you create monitors depends on which option you chose above.
    * If you started with _Project monitors_, you'll use the Elastic Synthetics library's **`push` command**.
      This requires an **API key and {kib} URL** to authenticate.
    * If you started with _Inline monitors_, you'll use the {kib} UI to select the location while configuring the monitor.
. There are two types of locations you can use.
    * **Global managed infrastructure**
    * **Private locations**
. The monitor will send data to **{es}** regardless of its location.
. **{kib}**, specifically the **{observability} {uptime-app}**, reads results from {es} and visualizes those results in the UI.
====

[discrete]
[[synthetic-monitor-choose-project]]
== Use project monitors

When you use the `@elastic/synthetics` library's `push` command to create monitors,
a new browser monitor is created in {kib} for each journey in your project.
Using the `push` command allows you to manage all browser monitors using a GitOps workflow.
Alternatively, you could keep monitors in sync directly from your local development environment.

We recommend users adopt a GitOps workflow when using project monitors because it allows teams to keep their monitors in sync with their project's `main` branch.
Besides saving time through automation, a GitOps workflow allows users to take advantage of PR reviews and checks that could validate journeys even before they are merged.

Project monitors also allow teams to configure individual monitors through code. Instead of using {kib} to update a monitor's schedule, for example, you can set a `schedule` directly in your journey. That `schedule` will be used when pushing the journey to {kib}.

[[monitor-use]]
When you're ready to create a browser monitor to run your tests, you'll need to set a few configuration options:

// lint ignore params
* **Give your monitor a name.** Provide a human readable name and a unique ID for the monitor. This will appear in {kib} where you can view and manage monitors after they're created.
* **Set the schedule.** Specify the interval at which your tests will run.
* **Specify where the monitors should run.** You can run monitors on Elastic's global managed testing infrastructure
or <<synthetics-private-location,create a private location>> to run monitors from your own premises.
* **Set other options as needed.** There are several other options you can set to customize your implementation including params, tags, screenshot options, throttling options, and more.

Configure each monitor directly in your test code using `monitor.use`.
The `monitor` API allows you to set unique options for each journey's monitor directly through code.
For example:

[source,js]
----
import { journey, step, monitor, expect } from '@elastic/synthetics';

journey('Ensure placeholder is correct', ({ page, params }) => {
  monitor.use({
    id: 'example-monitor',
    schedule: 10,
    throttling: {
      download: 10,
      upload: 5,
      latency: 100,
    },
  });
  step('Load the demo page', async () => {
    await page.goto('https://elastic.github.io/synthetics-demo/');
  });
  step('Assert placeholder text', async () => {
    const placeholderValue = await page.getAttribute(
      'input.new-todo',
      'placeholder'
    );
    expect(placeholderValue).toBe('What needs to be done?');
  });
});
----

For each journey, you can specify its `schedule` and the `locations` in which it runs.
When those options are not set, Synthetics will use the default values in the global configuration file.
For more details, see <<synthetics-configuration>>.

Here are all the available `monitor` configuration options:

include::synthetics-configuration.asciidoc[tag=monitor-config-options]

[discrete]
[[monitor-create]]
== Create monitor in {kib}

// tag::push-instructions[]
After setting configuration options, use the `push` command to create monitors and start collecting data.
The `push` command will create a monitor in {kib} for each local journey 
so you manage all the browser monitors from your local environment.

Push journeys to {kib} using:

[source,sh]
----
npx @elastic/synthetics push --auth <api-key> --url <kibana-url> --project <id|name>
----

To generate an API key:

. Go to **Monitor Management** in the {uptime-app}.
. Click **API Keys**.
. Click **Generate API key**.

image::images/synthetics-monitor-management-api-key.png[API Keys tooltip on the Uptime app's Monitor Management page]

NOTE: If you are pushing to a <<synthetics-private-location,private location>>, you must use an API key generated in 8.4 or higher.

For more details on using the `push` command, see <<elastic-synthetics-push-command>>.
// end::push-instructions[]

One monitor will appear on the **Monitor management** page for each journey.

[discrete]
[[synthetics-inline-journey]]
== Use an inline script

Alternatively, you can create a browser monitor using an _inline script_ in the {uptime-app}.

An inline browser monitor is a single journey that you manage individually.
Inline monitors can be quick to set up, but can also be more difficult to manage.
Each inline browser monitor can contain only _one_ journey, which must be maintained directly in {kib} or in your {heartbeat} configuration file.

If you depend on external packages, have your journeys next to your code repository, or wish to embed and manage more than one journey from a single monitor configuration, see <<monitor-use>> instead.

When writing an inline browser monitor, the `journey` keyword isn't required, and variables like `page` and `params` will be part of your script's scope. 

Add an inline browser monitor when configuring the Elastic Synthetics integration.
In *Monitor settings*, use the *Monitor Type* _Browser_.

[role="screenshot"]
image::images/synthetics-integration.png[Synthetics integration]

Then switch the *Source Type* to _Inline script_.

Add steps to the code block directly.
The `journey` keyword isn't required, and variables like `page` and `params` will be part of your script's scope.
You cannot `import` any dependencies when using inline browser monitors.

[role="screenshot"]
image::images/synthetics-integration-inline-script.png[Configure a synthetic monitor using an inline script in Elastic {fleet}]

Click *Advanced Browser options* to see more ways to configure your monitor.

* Use the *Synthetics agent options* to provide fine-tuned configuration for the synthetics agent.
Read more about available options in <<synthetics-command-reference>>.
* Use *Throttling options* to control the monitor's network speed.
You can control the monitor's download and upload speeds and its latency to simulate your application's behavior on slower or laggier networks.

When applying the integration policy to an {agent} policy, make sure to select your dedicated synthetics agent policy.

[role="screenshot"]
image::synthetics-agent-policy-select.png[Select your dedicated synthetics agent policy]

[discrete]
[[synthetics-ci]]
== Run on CI

You can also run a synthetic project on your CI environment. Elastic's synthetics runner can output results in a few different formats, including JSON and JUnit
(the standard format supported by most CI platforms).

If any of your journeys fail, the synthetics agent it will yield a non-zero exit code, which most CI systems pick up as a failure by default.

You can see an example using GitHub Actions in the
https://github.com/elastic/synthetics-demo/blob/main/.github/workflows/run-synthetics.yml[elastic/synthetics-demo] repository.
This example sets up a job that executes the synthetics runner and tells the runner to yield results in a JUnit format.