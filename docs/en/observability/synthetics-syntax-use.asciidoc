[[synthetics-syntax-use]]
= Synthetics syntax and use cases

++++
<titleabbrev>Syntax and use cases </titleabbrev>
++++

experimental::[]

To write synthetic tests for your application, you'll need to know basic JavaScript and
{playwright-url}[Playwright] syntax.
Elastic also provides two custom syntax elements:

* `journey` -- A journey tests one discrete unit of functionality.
For example, logging in to website, adding something to a cart, or joining a mailing list.
* `step` -- A journey consists of multiple steps, or actions, that should be completed in a specific order.
Steps are displayed individually in the {uptime-app} for easy debugging and error tracking.
// I believe there are now more syntax elements. Commenting out for now
// * `before` --
// * `beforeAll` --
// * `after` --
// * `afterAll` --

TIP: {playwright-url}[Playwright] is browser testing library developed by Microsoft.
It is reliable and fast and features a modern API that auto waits for page elements to be ready.

[discrete]
== Create a `journey`

The `journey` function takes two main parameters, `page` and `params`:

* `page` -- A `page` object from Playwright that lets you control the browsers current page.
* `params` -- User defined variables that allow you to invoke the Synthetics suite with custom parameters.
For example, if you want to use a different homepage depending on the `env`
(localhost for `dev`, and a URL for `prod`).

Putting it all together, a basic, two step journey might look something like this:

[source,js]
----
journey("Journey title", async ({page}) => {
    step("Step 1 title", async () => {
      // Do something here
    })
    step("Step 2 title", async () => {
      // Do something else here
    })
});
----

// REVIEWERS
// Should we add a note here about the `async` keyword / promises / link to mdn docs?
// https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await[async/await].

[discrete]
== Create a `step`

Steps can be as simple or complex as you need them to be.
The {playwright-api-docs}[Playwright page API reference] will be your friend while writing tests.

A basic first step might simply load a page:

[source,js]
----
await page.goto('https://www.elastic.co'); <1>
----
<1> See the https://github.com/microsoft/playwright/blob/master/docs/api.md#pagegotourl-options[`page.goto` reference] for more information.

A more complex second step might wait for a page element to be selected,
and then ensure that it matches an expected value.
Consider the following HTML snippet:

[source,html]
----
<header class="header">
  <h1>todos</h1>
  <input class="new-todo"
    autofocus autocomplete="off"
    placeholder="What needs to be done?"
    v-model="newTodo"
    @keyup.enter="addTodo">
</header>
----

You can verify that `new-todo` class element contains the expected `placeholder` (input hint)
with the following test:

[source,js]
----
const input = await page.$('input.new-todo'); <1>
deepStrictEqual(await input.getAttribute('placeholder'), "What needs to be done?"); <2>
----
<1> Query the page for the `input.new-todo` selector.
See the https://github.com/microsoft/playwright/blob/master/docs/api.md#pageselector[`page.$` reference] for more information.
<2> Return the `placeholder` attribute for `new-todo` with https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute[`getAttribute()`], and ensure it equals the provided text.
`deepStrictEqual` is provided by Node.js and tests for deep equality between the actual and
expected parameters.
See the https://nodejs.org/api/assert.html#assert_assert_deepstrictequal_actual_expected_message[Node.js API reference] for more information.

[discrete]
== Sample Synthetic test

// Need to expand on this text
Example from above

[source,js]
----
journey("Ensure placeholder is correct", async ({page}) => {
    step("Go to elastic.co", async () => {
      await page.goto('https://www.elastic.co');
    })
    step("Check placeholder text", async () => {
      const input = await page.$('input.new-todo');
      deepStrictEqual(await input.getAttribute('placeholder'), "What needs to be done?");
    })
});
----

[discrete]
[[running-synthetic-tests]]
== Create a new synthetic test

// REVIEWERS:
// Should we doc required technologies?
// Node.js, npx, typescript, etc.?

// REVIEWERS:
// A lot of this is described on the quickstart page. It feels repetitive.
// It also still needs some work.
// I think things have changed.

As explained in the <<synthetics-get-started,quickstart>>, there are two ways to run synthetic tests:

* Inline journey -- copy/paste into `heartbeat.yml`
* Simple test -- using inline yaml
* Test suite -- import your tests to

Which option is right for you? That depends.
From a workflow perspective, perhaps it makes more sense for you to paste your tests into yaml.
Yaml isn't a great dev experience though.

[discrete]
== Create an inline journey

The easiest way to run a synthetic test is by creating an inline journey:
Copy/paste your test steps into `heartbeat.yml`.
The `journey` keyword isn't required, and access to variables like `page` and `params` is automatic.
Heartbeat will fork Node.js, schedule your tests, and start headless chrome.
You don't need to worry about anything else.

An example is provided in the elastic/synthetics GitHub repo.
https://github.com/elastic/synthetics/tree/master/examples/inline

Take a look at `short.js`:

[source,js]
----
// test-homepage-hover.js
step("load homepage", async () => {
    await page.goto('https://www.elastic.co');
});
step("hover over products menu", async () => {
    await page.hover('css=[data-nav-item=products]');
});
----

`cd` into the directory with your journey and test it by piping the file contents into
the `elastic-synthetics` command.
For example:

[source,sh]
----
cat examples/inline/short.js | npx synthetics --inline
----

If everything works as expected, you'll get the following response:

[source,sh]
----
Journey: inline
   ✓  Step: 'load homepage' succeeded (1831 ms)
   ✓  Step: 'hover over products menu' succeeded (97 ms)

 2 passed (2511 ms)
----

The script can then be copied into your in your `heartbeat.yml`:

[source,yml]
----
heartbeat.monitors:
- type: browser
  id: my-monitor
  name: My Monitor
  schedule: "@every 1m"
  script: |-
    step("load homepage", async () => {
        await page.goto('https://www.elastic.co');
    });
    step("hover over products menu", async () => {
        await page.hover('css=[data-nav-item=products]');
    });
----

[discrete]
== Prepare a test suite

// AKA using Elastic/synthetics as a library
// Dockerize everything --> Docker runs Heartbeat and @elastic/synthetics

If you have a suite of tests you'd like to implement, you can use Elastic synthetics as a library.
This allows you to utilize Docker to run Heartbeat and `elastic-synthetics`.

. Create a new Node.js project.
. Create a `javascript` or `typescript` file that imports your tests.
. Call `run`, which is imported from `elastic-synthetics` and runs the CLI application.
. Compile everything together.

An example is provided in `synthetics/examples/todo`.
`cd` into the directory and install the dependencies:

[source,sh]
----
cd into `synthetics/examples/todos/`
`npm install`
----

Full NPM project oriented around these tests.
* Run `cat run-journeys` to compile the typescript (essentially by running `tsc`)
* Run `node ./dist` (or for help, append `-h`)

[discrete]
=== Caveats

How do you get your test suite onto the same box as Heartbeat?::
If you, for example, have a separate git repo with all of your tests, how do you get them onto the box?
You need to write some orchestration to get Heartbeat on a box (or use the docker image),
pull your source of tests, and then share it with Heartbeat.


// NOTES BELOW
Use case -- Whole app testing (big)

** WHAT DO WE NEED TO DOC?
- Playwright is provided - link to docs (API ref is the most interesting)
- Which variables are provided to journey (step receives none)
- And journey and step keywords

// Designing your own tests


// install first
npm i

// build it
npm run build