[[synthetics-syntax-use]]
= Synthetics syntax and use cases

++++
<titleabbrev>Syntax and use cases </titleabbrev>
++++

experimental::[]

To write synthetic tests for your application, you'll need to know basic JavaScript and
{playwright-url}[Playwright] syntax.
Elastic also provides two custom syntax elements:

* `journey` -- A journey tests one discrete unit of functionality.
For example, logging in to website, adding something to a cart, or joining a mailing list.
* `step` -- A journey consists of multiple steps, or actions, that should be completed in a specific order.
Steps are displayed individually in the {uptime-app} for easy debugging and error tracking.

TIP: {playwright-url}[Playwright] is browser testing library developed by Microsoft.
It is reliable and fast and features a modern API that auto waits for page elements to be ready.

[discrete]
== Create a `journey`

The `journey` function takes two main parameters, `page` and `params`:

* `page` -- A `page` object from Playwright that lets you control the browsers current page.
* `params` -- User defined variables that allow you to invoke the Synthetics suite with custom parameters.
For example, if you want to use a different homepage depending on the `env`
(localhost for `dev`, and a URL for `prod`).

Putting it all together, a basic, two step journey might look something like this:

[source,js]
----
journey("Journey title", async ({page}) => {
    step("Step 1 title", async () => {
      // Do something here
    })
    step("Step 2 title", async () => {
      // Do something else here
    })
});
----

// REVIEWERS
// Should we add a note here about the `async` keyword / promises / link to mdn docs?
// https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await[async/await].

[discrete]
== Create a `step`

Steps can be as simple or complex as you need them to be.
The {playwright-api-docs}[Playwright page API reference] will be your friend while writing tests.

A basic first step might simply load a page:

[source,js]
----
await page.goto('https://www.elastic.co'); <1>
----
<1> See the https://github.com/microsoft/playwright/blob/master/docs/api.md#pagegotourl-options[`page.goto` reference] for more information.

A more complex second step might wait for a page element to be selected,
and then ensure that it matches an expected value.
Consider the following HTML snippet:

[source,html]
----
<header class="header">
  <h1>todos</h1>
  <input class="new-todo"
    autofocus autocomplete="off"
    placeholder="What needs to be done?"
    v-model="newTodo"
    @keyup.enter="addTodo">
</header>
----

You can verify that `new-todo` class element contains the expected `placeholder` (input hint)
with the following test:

[source,js]
----
const input = await page.$('input.new-todo'); <1>
deepStrictEqual(await input.getAttribute('placeholder'), "What needs to be done?"); <2>
----
<1> Query the page for the `input.new-todo` selector.
See the https://github.com/microsoft/playwright/blob/master/docs/api.md#pageselector[`page.$` reference] for more information.
<2> Return the `placeholder` attribute for `new-todo` with https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute[`getAttribute()`], and ensure it equals the provided text.
`deepStrictEqual` is provided by Node.js and tests for deep equality between the actual and
expected parameters.
See the https://nodejs.org/api/assert.html#assert_assert_deepstrictequal_actual_expected_message[Node.js API reference] for more information.

[discrete]
== Sample Synthetic test

Example from above

[source,js]
----
journey("Ensure placeholder is correct", async ({page}) => {
    step("Go to elastic.co", async () => {
      await page.goto('https://www.elastic.co');
    })
    step("Check placeholder text", async () => {
      const input = await page.$('input.new-todo');
      deepStrictEqual(await input.getAttribute('placeholder'), "What needs to be done?");
    })
});
----

// Everything below this is TODO

// -------------------------------------------------------------------------------------------
// How to run your tests
// -------------------------------------------------------------------------------------------

[discrete]
[[running-synthetic-tests]]
== Running synthetic tests

// REVIEWERS:
// Should we doc required technologies?
// Node.js, npx, typescript, etc.?

There are two ways to run tests.

Which option is right for me?

From a workflow perspective, perhaps it makes more sense for you to paste your tests into yaml.
Yaml is not a nice dev experience though.

**Copy/pasting into YML**

// AKA an "inline journey"
// Heartbeat will fork Node and start headless chrome
// You don't have to worry about anything else

The easiest way to run your tests is by copy/pasting them into a JavaScript file and
including that file in your `heartbeat.yml` configuration.
In this instance, there's no `journey` required -- only `step`s.
Access to variables like `page` and `params` is automatic.

Here's a basic example:

[source,js]
----
// test-homepage-hover.js
step("load homepage", async () => {
    await page.goto('https://www.elastic.co');
});
step("hover over products menu", async () => {
    await page.hover('css=[data-nav-item=products]');
});
----

Test your script with the following command:

// To do: link to command line arguments

[source,sh]
----
npx @elastic/synthetics path/to/your/journey.js
----

The script can then be included in your `heartbeat.yml`:

[source,yml]
----
- type: browser
  id: test-homepage-hover
  name: Homepage hover test
  schedule: "@every 1m"
  file: test-homepage-hover.js
----

**Test suite**

// AKA using Elastic/synthetics as a library
// Dockerize everything --> Docker runs Heartbeat and @elastic/synthetics

If you have a suite of tests you'd like to implement, you can use Elastic synthetics as a library.
The basic process is below, and it acts like the `npx @elastic/synthetics` command seen in the inline-journey.

. Create a Node.js project
. Write an `index.ts` file that imports your tests
. Call `run`, which is imported from `@elastic/synthetics`.
This runs the CLI application.
. Compile everything together.

// example: examples/elastic-docs

Full NPM project oriented around these tests.
* Run `cat run-journeys` to compile the typescript (essentially by running `tsc`)
* Run `node ./dist` (or for help, append `-h`)

[discrete]
=== Caveats

How do you get your test suite onto the same box as Heartbeat?::
If you, for example, have a separate git repo with all of your tests, how do you get them onto the box?
You need to write some orchestration to get Heartbeat on a box (or use the docker image),
pull your source of tests, and then share it with Heartbeat.



// NOTES BELOW
Use case -- Whole app testing (big)

** WHAT DO WE NEED TO DOC?
- Playwright is provided - link to docs (API ref is the most interesting)
- Which variables are provided to journey (step receives none)
- And journey and step keywords

// Designing your own tests
