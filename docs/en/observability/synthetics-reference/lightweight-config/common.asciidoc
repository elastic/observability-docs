:hardbreaks-option:

[%header]
|===
| Option (type) | Description

// type
| [[monitor-type]] *`type`*
(`"http"` \| `"icmp"` \| `"tcp"`)
a| *Required*. The type of monitor to run. One of:

* `http`: Connects via HTTP and optionally verifies that the host returns the expected response.
* `icmp`: Uses an ICMP (v4 and v6) Echo Request to ping the configured hosts. Requires special permissions or root access.
* `tcp`: Connects via TCP and optionally verifies the endpoint by sending and/or receiving a custom payload.

////////////////////////
id
////////////////////////
| [[monitor-id]] *`id`*
(<<synthetics-lightweight-data-string,string>>)
a| *Required*. A unique identifier for this configuration. This should not change with edits to the monitor configuration regardless of changes to any config fields.

*Examples*:

[source,yaml]
id: uploader-service

[source,yaml]
id: http://example.net

[NOTE]
====
When querying against indexed monitor data this is the field you will be aggregating with. Appears in the exported fields as `monitor.id`.

If you do not set this explicitly the monitor's config will be hashed and a generated value used. This value will change with any options change to this monitor making aggregations over time between changes impossible. For this reason it is recommended that you set this manually.
====

////////////////////////
name
////////////////////////
| [[monitor-name]] *`name`*
(<<synthetics-lightweight-data-string,string>>)
a| Human readable name for this monitor.

*Examples*: 

[source,yaml]
name: Uploader service

[source,yaml]
name: Example website

////////////////////////
service.name
////////////////////////
| [[monitor-service_name]] *`service.name`*
(<<synthetics-lightweight-data-string,string>>)
a| APM service name for this monitor. Corresponds to the `service.name` ECS field. Set this when monitoring an app that is also using APM to enable integrations between Uptime and APM data in Kibana.

////////////////////////
enabled
////////////////////////
| [[monitor-enabled]] *`enabled`*
(<<synthetics-lightweight-data-bool,boolean>>)
a| Whether the module is enabled.

*Default*: `true`

*Example*:

[source,yaml]
enabled: false

////////////////////////
schedule
////////////////////////
| [[monitor-schedule]] *`schedule`*
(<<synthetics-lightweight-data-duration,duration>>)
a| *Required*. The task schedule.

*Example*:
Run the task every 5 seconds from the time the monitor was started.

[source,yaml]
schedule: @every 5s

////////////////////////
timeout
////////////////////////
| [[monitor-timeout]] *`timeout`*
(<<synthetics-lightweight-data-duration,duration>>)
a| The total running time for each ping test. This is the total time allowed for testing the connection and exchanging data.

*Default*: `16s`

*Example*:

[source,yaml]
timeout: 2m

////////////////////////
tags
////////////////////////
| [[monitor-tags]] *`tags`*
(list of <<synthetics-lightweight-data-string,string>>ss)
a| A list of tags that will be sent with the monitor event.

*Examples*:

[source,yaml]
----
tags:
  - tag one
  - tag two
----

[source,yaml]
----
tags: ["tag one", "tag two"]
----

|===

:!hardbreaks-option:

////
Heartbeat options that are not supported (yet or maybe ever?)
in Synthetics

| [[monitor-ipv4]] *`ipv4`*
(<<synthetics-lightweight-data-bool,boolean>>)
a|  Whether to ping using the ipv4 protocol if hostnames are configured.

*Default*: `true`

*Example*:

[source,yaml]
ipv4: false

| [[monitor-ipv6]] *`ipv6`*
(<<synthetics-lightweight-data-bool,boolean>>)
a|  Whether to ping using the ipv6 protocol if hostnames are configured.

*Default*: `true`

*Example*:

[source,yaml]
ipv6: false

| [[monitor-mode]] *`mode`*
(`"any"` \| `"all"`)
a| One of two modes in which to run the monitor:

* `any`: The monitor pings only one IP address for a hostname.
* `all`: The monitor pings all resolvable IPs for a hostname.

*Default*: `any`

*Example*:
You're using a DNS-load balancer and want to ping every IP address for the specified hostname.

[source,yaml]
mode: all

| [[monitor-run-from]] *`run_from`*
a| Use the `run_from` option to set the geographic location fields relevant to a given monitor.

The `run_from` option takes two top-level fields:

`id` (<<synthetics-lightweight-data-string,string>>):: A string used to uniquely identify the geographic location. It is indexed as the `observer.name` field.

`geo` ({ecs-ref}/ecs-geo.html[ECS geo fields]):: A map conforming to {ecs-ref}/ecs-geo.html[ECS geo fields]. It is indexed under `observer.geo`.

*Example*:

[source,yaml]
----
run_from:
  id: my-custom-geo
  geo:
    name: nyc-dc1-rack1
    location: 40.7128, -74.0060
    continent_name: North America
    country_iso_code: US
    region_name: New York
    region_iso_code: NY
    city_name: New York
----

| [[monitor-fields]] *`fields`*
a| Fields that you can specify to add additional information to the output.

You might add fields that you can use for filtering log data. Fields can be scalar values, arrays, dictionaries, or any nested combination of these.

By default, the fields that you specify here will be grouped under a `fields` sub-dictionary in the output document. To store the custom fields as top-level fields, set the `fields_under_root` option to true.

If a duplicate field is declared in the general configuration, then its value will be overwritten by the value declared here.

*Examples*: 

[source,yaml]
----
fields:
  instance_id: i-10a64379
  region: us-east-1
----

[source,yaml]
----
fields: {project: "myproject", region: "us-east-1"}
----

| [[monitor-fields-under-root]] *`fields_under_root`*
(<<synthetics-lightweight-data-bool,boolean>>)
a| If this option is set to `true`, the custom <<monitor-fields,fields>> are stored as top-level fields in the output document instead of being grouped under a `fields` sub-dictionary.

If the custom field names conflict with other field names added by {heartbeat}, then the custom fields overwrite the other fields.

*Example*:

[source,yaml]
----
fields_under_root: true
fields:
  instance_id: i-10a64379
  region: us-east-1
----

[source,yaml]
----
fields_under_root: true
fields: {project: "myproject", region: "us-east-1"}
----

| [[monitor-processors]] *`processors`*
(list of {heartbeat-ref}/defining-processors.html[processors])
a| A list of processors to apply to the data generated by the monitor. For a list of all processors, read the {heartbeat-ref}/defining-processors.html[Processor documentation].

*Examples*:

[source,yaml]
----
processors:
  - add_fields:
      target: project
      fields:
        name: myproject
        id: '574734885120952459'
  - add_cloud_metadata: ~
----

| [[monitor-data-stream]] *`data_stream`*
(<<synthetics-lightweight-data-string,string>>)
a| Contains options pertaining to data stream naming, following the conventions followed by {fleet-guide}/data-streams.html[Fleet Data Streams]. By default Heartbeat will write to a datastream named `heartbeat-VERSION`.

*Default*: `heartbeat-VERSION`

*Example*:

[source,yaml]
----
# To enable data streams with the default namespace
data_stream.namespace: default
----


| [[monitor-pipeline]] *`pipeline`*
(<<synthetics-lightweight-data-string,string>>)
a| The {es} ingest pipeline ID to set for the events generated by this input.

NOTE: The pipeline ID can also be configured in the Elasticsearch output, but this option usually results in simpler configuration files. If the pipeline is configured both in the input and output, the option from the input is used.

*Example*:

[source,yaml]
pipeline: 'abc123'


| [[monitor-keep-null]] *`keep_null`*
(<<synthetics-lightweight-data-bool,boolean>>)
a| If this option is set to true, fields with `null` values will be published in the output document.

*Default*: `false`

*Example*:

[source,yaml]
keep_null: true

////
